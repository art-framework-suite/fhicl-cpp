Thread-safety summary by subsystem and component.


Parameter File Parsing

// The value held by an intermediate table,
// which is the result of a fhicl file parse,
// and the internal sub-components of the
// parse.
// Used by public.
// THREADING - Not thread-safe.
extended_value.cc
extended_value.h
// handles protect clauses.
// Used only by extended_value.h
// THREADING - Is thread-safe.
Protection.cc
Protection.h
// Support snippet mode.  (what is that?)
// Used only by extended_value.h
// THREADING - Not thread-safe.
stdmap_shims.h

// The result of a fhicl file parse.
// Used by public.
// THREADING - Not thread-safe.
intermediate_table.cc
intermediate_table.h

// The fhicl file parser, the stream parser,
// and the string parser.
// Note: For greater code isolation the
// Note: public part (top-level parsing
// Note: for strings, files, and streams)
// Note: should be separated out.
// Used by public.
// THREADING - Not thread-safe - can modify passed value.
parse.cc
parse.h
// The tokens used by the fhicl parser.
// Used only by parse.cc
// THREADING - Is thread-safe.
tokens.h
// support for the fhicl parser,
// handles protect clauses.
// Used only by parse.cc and tokens.h
// THREADING - Is thread-safe.
binding_modifier.h
// Support snippet mode.  (what is that?)
// Used only by parse.cc
// THREADING - Is thread-safe.
parse_shims.cc
parse_shims.h

// Support snippet mode.  (what is that?)
// Used by parse_shims.h, parse_shims.cc, stdmap_shims.h
// THREADING - Is thread-safe.
parse_shims_opts.h

// supports ParameterSet::put(extended_value)
// for conversion of result of fhicl file
// parsing (intermediate_table).
// Used only by ParameterSet.h
// THREADING - Not thread-safe.
encode_extended_value.cc
encode_extended_value.h

// supports ParameterSet::put()
// FIXME: Should probably only be used by ParameterSet!
// Used by public.
// THREADING - Not thread-safe.
coding.cc
coding.h


Parameter Storage/Retrieval

// Used only by tools/fhicl-write-db.cc
// THREADING - Not thread-safe.
DatabaseSupport.cc
DatabaseSupport.h

// Holds a representation of configuration
// values.  Can be parsed from a fhicl file,
// or built by hand.
// Used by public.
// THREADING - Not thread-safe.
ParameterSet.cc
ParameterSet.h
// Used only by ParameterSet.h
// THREADING - Not thread-safe - find_an_any is passed an iterator
ParameterSetImplHelpers.h
// Used only by ParameterSet.h
// THREADING - Not thread-safe - passed an executable object
try_blocks.h
// Used only by ParameterSet.cc
// THREADING - Not thread-safe
KeyAssembler.cc
KeyAssembler.h

// The unique name of a ParameterSet.
// Implemented as the sha1 hash of the
// contents of the ParameterSet::mapping_.
// Used by public.
// THREADING - Not thread-safe.
ParameterSetID.cc
ParameterSetID.h

// Master registry of ParameterSets.
// Keyed by ParameterSetID.
// Backed by in-memory and on-file dbs.
// THREADING - Not thread-safe.
ParameterSetRegistry.cc
ParameterSetRegistry.h

// Almost not used, can probably be eliminated.
// forward declares: ParameterSet, ParameterSetID,
// extended_value, intermediate_table
// Used by public.
// THREADING - Is thread-safe.
fwd.h

// Factory functions to create a ParameterSet
// from a string, file, or intermediate_table.
// Used by public.
// THREADING - Not thread-safe.
make_ParameterSet.cc
make_ParameterSet.h


Parameter Validation

// THREADING - Not yet determined
Atom.h
Atom.icc

// THREADING - Not yet determined
AtomBase.h

// THREADING - Not yet determined
Comment.h

// THREADING - Not yet determined
ConfigPredicate.h

// THREADING - Not yet determined
DelegateBase.h

// THREADING - Not yet determined
DelegatedParameter.cc
DelegatedParameter.h

// THREADING - Not yet determined
KeysToIgnore.h (testing only)

// THREADING - Not yet determined
MaybeDisplayParent.cc
MaybeDisplayParent.h

// THREADING - Not yet determined
Name.cc
Name.h

// THREADING - Not yet determined
NameStackRegistry.cc
NameStackRegistry.h

// THREADING - Not yet determined
OptionalAtom.h
OptionalAtom.icc

// THREADING - Not yet determined
OptionalDelegatedParameter.cc
OptionalDelegatedParameter.h

// THREADING - Not yet determined
OptionalSequence.h
OptionalSequence.icc

// THREADING - Not yet determined
OptionalTable.h
OptionalTable.icc

// THREADING - Not yet determined
OptionalTuple.h

// THREADING - Not yet determined
OptionalTupleAs.h

// THREADING - Not yet determined
ParameterArgumentTypes.h

// THREADING - Not yet determined
ParameterBase.h

// THREADING - Not yet determined
ParameterMetadata.h

// THREADING - Not yet determined
ParameterWalker.h

// THREADING - Not yet determined
PrintAllowedConfiguration.cc
PrintAllowedConfiguration.h

// THREADING - Not yet determined
SeqVectorBase.h

// THREADING - Not yet determined
Sequence.h
Sequence.icc

// THREADING - Not yet determined
SequenceBase.h

// THREADING - Not yet determined
Table.h
Table.icc

// THREADING - Not yet determined
TableBase.h

// THREADING - Not yet determined
TableFragment.h

// THREADING - Not yet determined
TableMemberRegistry.h

// THREADING - Not yet determined
Tuple.h

// THREADING - Not yet determined
TupleAs.h

// THREADING - Not yet determined
ValidateThenSet.cc
ValidateThenSet.h

// THREADING - Not yet determined
optional_parameter_message.h

// THREADING - Not yet determined
ostream_helpers.cc
ostream_helpers.h

// THREADING - Not yet determined
strip_containing_names.cc
strip_containing_names.h

// THREADING - Not yet determined
type_traits_error_msgs.h

// THREADING - Not yet determined
validationException.h (unused)


Parameter Pretty-Printing

// THREADING - Not yet determined
Indentation.h

// THREADING - Not yet determined
PrettifierAnnotated.cc
PrettifierAnnotated.h

// THREADING - Not yet determined
Prettifier.cc
Prettifier.h

// THREADING - Not yet determined
PrettifierPrefixAnnotated.cc
PrettifierPrefixAnnotated.h

// THREADING - Not yet determined
printing_helpers.cc
printing_helpers.h

// THREADING - Not yet determined
print_mode.h


Parameter Utility Routines

// THREADING - Not yet determined
ParameterSetWalker.h

// THREADING - Not yet determined
exception.cc
exception.h

// THREADING - Not yet determined
type_traits.h

-----

boost::any
boost::spirit
boost::qi

These boost libraries appear to be thread-safe.

Ordinary C++ i/o using streams is thread-safe.

-----

The ParameterSetRegistry class follows the Singleton pattern and is intended
to store information relevant to the entire art job in progress.

----------------------------------------------------------------
Interface of ParameterSetRegistry in pseudo-UML


class fhicl::detail::HashParameterSetID

  - hash_ : std::hash<std::string> hash_

  -----

  + operator()(ParameterSetID const& id) const : size_t


class fhicl::ParameterSetRegistry

  THREADING - - primaryDB_ : sqlite3*
  THREADING - - stmt_ : sqlite3_stmt*
  THREADING - - registry_ : std::unordered_map<ParameterSetID, ParameterSet, detail::HashParameterSetID>

  -----

  + typedef collection_type : std::unordered_map<ParameterSetID, ParameterSet, detail::HashParameterSetID>
  + typedef key_type : collection_type::key_type
  + typedef mapped_type : collection_type::mapped_type
  + typedef value_type : collection_type::value_type
  + typedef size_type : collection_type::size_type
  + typedef const_iterator : collection_type::const_iterator

  -----

  + ~ParameterSetRegistry(); - THREADING - CALLED ONLY AT lib unload, which is PROGRAM EXIT, global destructor time
  - ParameterSetRegistry() - THREADING -
  + ParameterSetRegistry(ParameterSet const&) = delete;
  + ParameterSetRegistry(ParameterSet&&) = delete;
  + operator=(ParameterSet const&) = delete : ParameterSetRegistry&
  + operator=(ParameterSet&&) = delete : ParameterSetRegistry& 
  - find_(ParameterSetID const& id) : const_iterator - THREADING - Can trigger a registry_.emplace(psid, pset) if not there, and then found in in-memory db, uses psid.to_string()
  - static instance_() : ParameterSetRegistry& - THREADING -
  + static importFrom(sqlite3* db) : void - THREADING -
  + static exportTo(sqlite3* db) : void - THREADING -
  + static stageIn() : void - THREADING -
  + static empty() : bool - THREADING - // UNUSED
  + static size() : size_type - THREADING - // UNUSED
  + static begin() : const_iterator - THREADING - // UNUSED
  + static end() : const_iterator - THREADING - // UNUSED
  + static cbegin() : const_iterator - THREADING - // UNUSED
  + static cend() : const_iterator - THREADING - USED (see find_ return value)
  + static get() noexcept : collection_type const& - THREADING - // Used only by config_dumper
  + static get(ParameterSetID const& id) : ParameterSet const&  - THREADING -
  + static get(ParameterSetID const& id, ParameterSet& ps) : bool - THREADING -
  + static put(collection_type const& c) : void - THREADING - // UNUSED
  + static put(ParameterSet const& ps) : ParameterSetID const&  - THREADING -

    // UNUSED
  + template<typename FwdIt>
    static
    put(FwdIt begin, FwdIt end) : std::enable_if_t<std::is_same<typename std::iterator_traits<FwdIt>::value_type, mapped_type>::value>

    // UNUSED
  + template<typename FwdIt>
    static
    put(FwdIt begin, FwdIt end) : std::enable_if_t<std::is_same<typename std::iterator_traits<FwdIt>::value_type, value_type>::value>



----------------------------------------------------------------
Usage in art of the interface


// config_dumper use (standalone executable, no threading issues)
./art/art/Framework/IO/Root/config_dumper.cc:192:    fhicl::ParameterSetRegistry::put(pset);
./art/art/Framework/IO/Root/config_dumper.cc:201:    fhicl::ParameterSetRegistry::importFrom(sqliteDB);
./art/art/Framework/IO/Root/config_dumper.cc:202:    fhicl::ParameterSetRegistry::stageIn();
./art/art/Framework/IO/Root/config_dumper.cc:231:  for (auto const& pr : fhicl::ParameterSetRegistry::get())

// importFrom
./art/art/Framework/IO/Root/RootInputFile.cc:231:        fhicl::ParameterSetRegistry::importFrom(sqliteDB_);

// exportTo
./art/art/Framework/IO/Root/RootOutputFile.cc:837:  fhicl::ParameterSetRegistry::exportTo(rootFileDB_);
./fhiclcpp/fhiclcpp/DatabaseSupport.cc:57:  fhicl::ParameterSetRegistry::exportTo(out);

// get
./art/art/Framework/Services/System/TriggerNamesService_service.cc:56:  if (! ParameterSetRegistry::get(triggerResults.parameterSetID(), pset))
./art/art/Framework/Services/UserInteraction/UserInteraction.cc:46:      fhicl::ParameterSetRegistry::get(md.parameterSetID(),
./art/art/Framework/Principal/Provenance.cc:20:  return fhicl::ParameterSetRegistry::get( *psetIDs().begin() );
./art/art/Framework/Principal/Event.cc:101:      ParameterSetRegistry::get(config.parameterSetID(), ps);
./art/art/Framework/Principal/Run.cc:41:      ParameterSetRegistry::get(id, temp);
./art/art/Framework/Core/OutputWorker.cc:20:                               fhicl::ParameterSetRegistry::get(description().parameterSetID()));
./art/art/Framework/Core/detail/get_failureToPut_flag.cc:11:    auto const& main_pset   = fhicl::ParameterSetRegistry::get( md.mainParameterSetID() );
./art/art/Framework/Core/detail/get_failureToPut_flag.cc:12:    auto const& pset        = fhicl::ParameterSetRegistry::get( md.parameterSetID() );
./fhiclcpp/fhiclcpp/ParameterSet.cc:57:    return ParameterSetRegistry::get(psid);
./fhiclcpp/fhiclcpp/ParameterSet.cc:71:    result = '{' + ParameterSetRegistry::get(psid).to_string() + '}';
./fhiclcpp/fhiclcpp/coding.cc:215:  result = ParameterSetRegistry::get(id);

// put
./art/art/Framework/Services/System/TriggerNamesService_service.cc:36:  ParameterSetRegistry::put(trigger_pset_);
./art/art/Framework/Art/run_art.cc:134:    fhicl::ParameterSetRegistry::put(main_pset);
./art/art/Framework/Art/run_art.cc:179:    fhicl::ParameterSetRegistry::put(main_pset);
./art/art/Framework/EventProcessor/ServiceDirector.cc:22:    fhicl::ParameterSetRegistry::put(tmp);
./art/art/Framework/IO/Root/RootInputFile.cc:224:      fhicl::ParameterSetRegistry::put(pset);
./fhiclcpp/fhiclcpp/DatabaseSupport.cc:56:  fhicl::ParameterSetRegistry::put(top);
./fhiclcpp/fhiclcpp/coding.cc:126:  return ParameterSetRegistry::put(value);
./fhiclcpp/fhiclcpp/detail/encode_extended_value.cc:54:    return ParameterSetRegistry::put(result);


----------------------------------------------------------------

Operation of the singleton fetcher.

inline
auto
fhicl::ParameterSetRegistry::
ParameterSetRegistry::instance_() -> ParameterSetRegistry&
{
  static ParameterSetRegistry s_registry;
  return s_registry;
}


The instance_() private static member function manages a function-local static
variable s_registry which is the process-wide single instance of the
ParameterSetRegistry class.  This means the private default constructor with
no arguments is run the first time the instance_() function is executed.

It is worth noting that the C++ Standard guarantees that function local static
initialization is thread-safe and that g++ does correctly implement this
requirement using a critical section.

The first time the instance_() function is run is in art::run_art()
when the parameter set is created from the intermediate table at
art/Framework/Art/run_art.cc:113 (verified by setting a breakpoint on the
fhicl::ParameterSetRegistry::instance_() function and running an art job).

See the discussion of make_ParameterSet() below.

This parameter set creation not only creates the ParameterSetRegistry, but
it also results in a complicated set of puts to the registry and uses of
ParameterSet::id(), neither of which is thread-safe.

THREADING - Creation of parameter set from the intermediate table is not thread-safe.

THREADING - Point of construction of the ParameterSetRegistry singleton instance.

fhicl::ParameterSetRegistry::
ParameterSetRegistry()
  : primaryDB_(openPrimaryDB())
  , stmt_(nullptr)
  , registry_()
{
}

The private default constructor with no arguments first calls openPrimaryDB()
to initialize the primaryDB_ data member, then sets stmt_ to the nullptr, and
then default initializes the registry_ data member.

FIXME: Note that openPrimaryDB() is called before stmt_ and registry_ have been
FIXME: initialized, it would be better to initialize primaryDB_ to nullptr, and
FIXME: later in the body of the constructor call openPrimaryDB() after stmt_
FIXME: and registry_ have been safely initialized.

The openPrimaryDB() function is in an unnamed namespace.  It calls sqlite3_open()
to create an in-memory database, then calls sqlite3_exec() to create the
ParameterSets table.  On failure of either step throwOnSQLiteFailure() is called.
The creation of the ParameterSets table is done in a transaction so either it
appears, or on error it does not, there will never be a partially created table.

The throwOnSQLiteFailure() function is passed a local database pointer and a local
pointer to the sql error message which was created by sqlite3.  It copies the
message and uses sqlite3_free to release the message storage.  If the database
pointer is the nullptr it throws a fhicl::exception.  Otherwise it calls
sqlite3_errcode to retrieve the pending error code from sqlite and then uses
sqlite3_errstr to translate the code to a message.  Then it calls sqlite3_errmsg
passing it the local database pointer to retrieve further information.  Then it
throws a fhicl::exception.

THREADING - ParameterSetRegistry construction is not thread-safe.

The uses of sqlite3 interfaces in the ParameterSetRegistry private default
constructor with no arguments form a transaction that must not be interleaved
with another attempted construction.  The thread-safety of sqlite3 is not clear,
callgrind traces show that pthread mutexes are being used, so there is some
attempt being made, must investigate interactions with tbb.

THREADING - sqlite3 thread-safety uses pthread, is it compatible with tbb?

Construction of the ParameterSetRegistry should not be interleaved with any
other uses of the sqlite3 interfaces to manipulate the parameter set database.
And possibly should not be mixed with any other used of sqlite3, this needs
further investigation.

Careful thought must also be given to the interaction of exception handling with
the thread tasking system in use.

THREADING - Must know how throwing an exception in a thread safely shuts down the other threads.

THREADING - Nearly all ParameterSetRegistry interfaces use instance_() and so may result in construction of the singleton instance at a time when it is not safe.

-----

Detailed source-based analysis.

// Encode extended value to a boost::any,
// Throw if key contains '.',
// Emplace (key, value(boost::any)) into mapping_,
// Throw if key was already there,
// Force future recalc of my id_ by invalidating it.
// Copy value source info into srcMapping_.
template<>
void
ParameterSet::
put(std::string const& key, fhicl::extended_value const& value)
  auto insert = [this, &key, &value]()
    // Encode extended value to a boost::any,
    // Throw if key contains '.',
    // Emplace (key, value(boost::any)) into mapping_,
    // Throw if key was already there,
    // Force future recalc of my id_ by invalidating it.
    insert_(key, boost::any(detail::encode(value))); - THREADING - encode may do a ParameterSetRegistry::put(pset) for tables
      insert_(string const& key, any const& value)
        check_put_local_key(key);
          check_put_local_key(std::string const& key)
            if (key.find('.') != std::string::npos)
              throw fhicl::exception(unimplemented, "putXXX() for nested key.");
        if (!mapping_.emplace(key, value).second) - THREADING -
          throw exception(cant_insert) << "key " << key << " already exists.";
        id_.invalidate(); - THREADING -
    // Copy value source info into srcMapping_.
    fill_src_info(value, key, srcMapping_);
      fill_src_info(extended_value const& value, std::string const& key, ParameterSet::annot_t& src_map)
        src_map[key] = value.src_info; - THREADING -
        if (!value.is_a(SEQUENCE))
          return;
        std::size_t i(0);
        for (auto const& xval : extended_value::sequence_t(value)) - THREADING -
          std::ostringstream oss;
          oss << key << "[" << i++ << "]";
          src_map[oss.str()] = xval.src_info; - THREADING -
          /*recursion*/ fill_src_info(xval, oss.str(), src_map); - THREADING -
  detail::try_insert(insert, key);
    ... runs insert(), throws on error, uses key for error msg

-----

Analyzed by callgrind.

make_ParameterSet(intermediate_table const&, ParameterSet&)
    // Set detailed source-based analysis above.
    ParameterSet::put<extended_value>(string const& key, extended_value const& value)
        // Convert the extended_value to a boost::any.
        // May recurse into ParameterSet::put<extended_value(key, value).
        // May calculate ParameterSetIDs which may query the ParameterSetRegistry.
        // May register parameter sets in the registry.
        detail::encode(extended_value const&)
            ParameterSet::put<extended_value>(string const&, extended_value const&)
                (cycle) back to ParameterSet::put
                or join with next
            ParameterSetRegistry::put(ParameterSet const&)
                // Fetch the singleton.
                THREADING - (already explained above) ParameterSetRegistry::instance_()
                // Fetch the parameter set id.
                ParameterSet::id()
                    // If not yet calculated, calculate.
                    THREADING - ParameterSetID::reset()
                        // Fetch tables by their parameter set id.
                        ParameterSetRegistry::get(ParameterSetID const&)
                            ParameterSetRegistry::find_(ParameterSetID const&)
                                THREADING - (registry_) unordered_map<ParameterSetID, ParameterSet>::find(ParameterSetID const&)
                    // Hash the result and return.
                // Insert the ParameterSet
                THREADING - (registry_) unordered_map<ParameterSetID, ParameterSet>::emplace<ParameterSetID, ParameterSet const&>(ParameterSetID&&, ParameterSet const&)
        // Emplace (key, value(boost::any)) into mapping_,
        ParameterSet::insert_(string const& key, boost::any const& value)
            THREADING - (mapping_) map<string, boost::any>::emplace(string const& key, boost::any const& value)
        // Copy value source info into srcMapping_.
        (anonymous)::fill_src_info(extended_value const&, string const&, (srcMapping_) unordered_map<string, string>&)
            THREADING - (srcMapping_) unordered_map<string, string>::operator[](string const&)
                    
                    
-----

class fhicl::ParameterSet

  + ps_atom_t : detail::ps_atom_t;
  + ps_sequence_t : detail::ps_sequence_t;
  + annot_t : unordered_map<string, string>;

  - mapping_ : map<string, boost::any> /*Note: ParameterSetID is generated by sha1 hashing a string version of the contents*/ - THREADING - all three data members must be interlocked against writers 
  - srcMapping_ : unordered_map<string, string> - THREADING - all three data members must be interlocked against writers
  - id_ : mutable ParameterSetID - THREADING - all three data members must be interlocked against writers

  + operator==(ParameterSet const& other) const : bool
  + operator!=(ParameterSet const& other) const : bool

  + is_empty() const : bool

    // Note: This may call ParameterSetRegistry::get(psid), which may construct ParameterSets and register them!
  + id() const : ParameterSetID

    // Note: These may call ParameterSetRegistry::get(psid), which may construct ParameterSets and register them!
  + to_string() const : string
  + to_compact_string() const : string

    // Note: These may call ParameterSetRegistry::get(psid), which may construct ParameterSets and register them!
  + to_indented_string() const : string
  + to_indented_string(unsigned initial_indent_level) const : string
  + to_indented_string(unsigned initial_indent_level, bool annotate) const : string
  + to_indented_string(unsigned initial_indent_level, detail::print_mode pm) const : string

  + get_names() const : vector<string>
  + get_pset_names() const : vector<string>

  + get_keys() const : [[deprecated(GET_KEYS_MSG)]] vector<string>
  + get_pset_keys() const : [[deprecated(GET_PSET_KEYS_MSG)]] vector<string>

  + get_all_keys() const : vector<string>

  + has_key(string const& key) const : bool
  + is_key_to_table(string const& key) const : bool
  + is_key_to_sequence(string const& key) const : bool
  + is_key_to_atom(string const& key) const : bool

  + get_if_present(string const& key, T& value) const : template<class T> bool 
  + get_if_present(string const& key, T& value, T convert(Via const&)) const : template<class T, class Via> bool 

  + get(string const& key) const : template<class T> T 
  + get(string const& key, T convert(Via const&)) const : template<class T, class Via> T 
  + get(string const& key, T const& default_value) const : template<class T> T 
  + get(string const& key, T const& default_value, T convert(Via const&)) const : template<class T, class Via> T

  + get_src_info(string const& key) const : string

  + put(string const& key) : void
  + put(string const& key, T const& value) : template<class T> void
  + put_or_replace(string const& key) : void
  + put_or_replace(string const& key, T const& value) : template<class T> void
  + put_or_replace_compatible(string const& key, T const& value) : template<class T> void

  + erase(string const& key) : bool

-----

class fhicl::ParameterSetID

  - valid_ : bool - THREADING - must be accessed in transaction with id_ 
  - id_ : cet::sha1::digest_t id_ - THREADING - array accessed by element, must be accessed in transaction with valid_

  + max_str_size() : static std::size_t
  + ParameterSetID()
  + ParameterSetID(ParameterSet const&) explicit - THREADING - uses pset.to_string()
  + ParameterSetID(std::string const& id) explicit
  + operator==(ParameterSetID const&) const : bool  - THREADING
  + operator!=(ParameterSetID const&) const : bool  - THREADING
  + operator<(ParameterSetID const&) const : bool  - THREADING
  + operator>(ParameterSetID const&) const : bool  - THREADING
  + operator<=(ParameterSetID const&) const : bool  - THREADING
  + operator>=(ParameterSetID const&) const : bool  - THREADING
  + is_valid () const : bool - THREADING
  + to_string() const : std::string - THREADING
  + invalidate() : void - THREADING
  + reset(ParameterSet const&) : void - THREADING
  + swap(ParameterSetID&) : void - THREADING


-----

These are the parameter set subsystems and their code files:


Parameter File Parsing

// support for the fhicl parser,
// handles protect clauses.
Protection.cc
Protection.h
binding_modifier.h

// supports ParameterSet::put()
coding.cc
coding.h

// supports ParameterSet::put(extended_value)
// for conversion of result of fhicl file
// parsing (intermediate_table).
encode_extended_value.cc
encode_extended_value.h

// The value held by an intermediate table,
// which is the result of a fhicl file parse,
// and the internal sub-components of the
// parse.
extended_value.cc
extended_value.h

// The result of a fhicl file parse.
intermediate_table.cc
intermediate_table.h

// The fhicl file parser, the stream parser,
// and the string parser.
parse.cc
parse.h

// Support snippet mode.  (what is that?)
parse_shims.cc
parse_shims.h
parse_shims_opts.h
stdmap_shims.h

// The tokens used by the fhicl parser.
tokens.h


Parameter Storage/Retrieval

// Used only by tools/fhicl-write-db.cc
DatabaseSupport.cc
DatabaseSupport.h

ParameterSet.cc
ParameterSet.h
// Used only by ParameterSet.h
ParameterSetImplHelpers.h
// Used only by ParameterSet.h
try_blocks.h
// Used only by ParameterSet.cc
KeyAssembler.cc
KeyAssembler.h

ParameterSetID.cc
ParameterSetID.h

ParameterSetRegistry.cc
ParameterSetRegistry.h

// Almost not used, can probably be eliminated.
// forward declares: ParameterSet, ParameterSetID,
// extended_value, intermediate_table
fwd.h

// Factory functions to create a ParameterSet
// from a string, file, or intermediate_table.
make_ParameterSet.cc
make_ParameterSet.h


Parameter Validation

Atom.h
Atom.icc
AtomBase.h
Comment.h
ConfigPredicate.h
DelegateBase.h
DelegatedParameter.cc
DelegatedParameter.h
KeysToIgnore.h (testing only)
MaybeDisplayParent.cc
MaybeDisplayParent.h
Name.cc
Name.h
NameStackRegistry.cc
NameStackRegistry.h
OptionalAtom.h
OptionalAtom.icc
OptionalDelegatedParameter.cc
OptionalDelegatedParameter.h
OptionalSequence.h
OptionalSequence.icc
OptionalTable.h
OptionalTable.icc
OptionalTuple.h
OptionalTupleAs.h
ParameterArgumentTypes.h
ParameterBase.h
ParameterMetadata.h
ParameterWalker.h
PrintAllowedConfiguration.cc
PrintAllowedConfiguration.h
SeqVectorBase.h
Sequence.h
Sequence.icc
SequenceBase.h
Table.h
Table.icc
TableBase.h
TableFragment.h
TableMemberRegistry.h
Tuple.h
TupleAs.h
ValidateThenSet.cc
ValidateThenSet.h
optional_parameter_message.h
ostream_helpers.cc
ostream_helpers.h
strip_containing_names.cc
strip_containing_names.h
type_traits_error_msgs.h
validationException.h (unused)


Parameter Pretty-Printing

Indentation.h

PrettifierAnnotated.cc
PrettifierAnnotated.h

Prettifier.cc
Prettifier.h

PrettifierPrefixAnnotated.cc
PrettifierPrefixAnnotated.h

printing_helpers.cc
printing_helpers.h

print_mode.h


Parameter Utility Routines

ParameterSetWalker.h

exception.cc
exception.h

type_traits.h

-----

The sources of ParameterSets.

Note that in the end all of these ways either start
with a default-constructed ParameterSet object, then
use ParameterSet::put(key, value) to insert entries and
finally use ParameterSetRegistry::put(pset) to insert
the resulting ParameterSet into the registry, or they
copy from an on-disk db directly in the in-memory db
which later results in an insertion into the registry
when a get looks for it and finds it in the in-memory db.


o The config file and command line options in combination.

  Uses:
      // Mix config file and command lines together to
      // make an intermediate_table which then gets
      // converted to a parameter set.
      fhicl::intermediate_table raw_config;
      for auto & handler : handlers
          handler->processOptions(vm, raw_config);
          ... art::BasicOptionsHandler::doProcessOptions(bpo::variables_map const & vm, fhicl::intermediate_table & raw_config)
          ... ... fhicl::parse_document(vm["config"].as<std::string>(), maker_, raw_config);
      detail::handle_deprecated_configs(raw_config);
      fhicl::ParameterSet main_pset;
      make_ParameterSet(/*intermediate_table*/raw_config, main_pset);
      ... iterate over intermediate table
      ... use ParameterSet::put(key, value)
      fhicl::ParameterSetRegistry::put(main_pset);


o root input files, parameter set blobs and the newer per-file db

  Uses: 
      // ParameterSet map
      for auto const& psEntry : psetMap)
        fhicl::ParameterSet pset;
        fhicl::make_ParameterSet(/*string*/psEntry.second.pset_, pset);
        ... intermediate_table tbl;
        ... parse_document(string, tbl);
        ... make_ParameterSet(tbl, ps);
        ... ... iterate over intermediate table
        ... ... use ParameterSet::put(key, value)
        // Note ParameterSet::id() has the side effect of
        // making sure the parameter set *has* an ID.
        pset.id();
        fhicl::ParameterSetRegistry::put(pset);
  and:
      // per-file db
      fhicl::ParameterSetRegistry::importFrom(sqliteDB_);
      ... copies from on-disk db into in-memory db, ignores duplicated
      ... parameter set ids

o fcl files or strings parsed by user modules/tools/services

  Uses:
      // string-based
      fhicl::ParameterSet pset;
      void fhicl::make_ParameterSet(std::string const& str, ParameterSet& pset)
      ... intermediate_table tbl;
      ... parse_document(str, tbl);
      ... make_ParameterSet(tbl, ps);
      ... ... iterate over intermediate table
      ... ... use ParameterSet::put(key, value)
      // Note ParameterSet::id() has the side effect of
      // making sure the parameter set *has* an ID.
      pset.id();
      fhicl::ParameterSetRegistry::put(pset);
  Or:
      // file-based
      fhicl::ParameterSet pset;
      void fhicl::make_ParameterSet(std::string const& filename, cet::filepath_maker&, ParameterSet& pset)
      ... intermediate_table tbl;
      ... parse_document(filename, maker, tbl);
      ... make_ParameterSet(tbl, ps);
      ... ... iterate over intermediate table
      ... ... use ParameterSet::put(key, value)
      // Note ParameterSet::id() has the side effect of
      // making sure the parameter set *has* an ID.
      pset.id();
      fhicl::ParameterSetRegistry::put(pset);

o encode called by ParameterSet::put()

  Uses:
      // To insert a table from a parameter set
      // into the registry.
      ParameterSetID encode(ParameterSet const& value)
      ... return ParameterSetRegistry::put(value);
  And:
      // Used while creating a parameter set from
      // the results of a parse.
      boost::any encode(extended_value const& xval)
      ... switch (xval.tag)
      ... ... case TABLE:
      ... ... auto const& tbl = table_t(xval);
      ... ... ParameterSet pset;
      ... ... for (auto I = tbl.begin(), E = tbl.end(); I != E; ++I)
      ... ... ... if (!I->second.in_prolog)
      ... ... ... ... pset.put(I->first/*string*/, I->second/*extended_value*/);
      ... ... return ParameterSetRegistry::put(pset);


o messagefacility

  Uses:
        fhicl::ParameterSet
        MessageFacilityService::ConfigurationFile(std::string const& filename, fhicl::ParameterSet const& default_config)
            ...
            fhicl::ParameterSet pset; 
            try
              fhicl::make_ParameterSet(fname, *policy_ptr, pset);
              ... intermediate_table tbl;
              ... parse_document(filename, maker, tbl);
              ... make_ParameterSet(tbl, ps);
              ... ... iterate over intermediate table
              ... ... use ParameterSet::put(key, value)
              return pset; 
            catch (cet::exception &e)
              std::cerr << "Configuration file \"" << fname << "\" "
                        << "parsing failed with exception " << e.what()
                        << ".\n"
                        << "Default configuration will be used instead.\n";
            return default_config;
      And:
          auto pset_from_oss(std::ostringstream const& ss)
            fhicl::ParameterSet pset;
            std::string const pstr(ss.str());
            fhicl::make_ParameterSet(pstr, pset);
            ... intermediate_table tbl;
            ... parse_document(str, tbl);
            ... make_ParameterSet(tbl, ps);
            ... ... iterate over intermediate table
            ... ... use ParameterSet::put(key, value)
            return pset;
        All of these use the above to set a sub-table in the "destinations" table.
        fhicl::ParameterSet MessageFacilityService::logConsole()
        fhicl::ParameterSet MessageFacilityService::logServer(int const partition)
        fhicl::ParameterSet MessageFacilityService::logFile(std::string const& filename, bool const append)
        fhicl::ParameterSet MessageFacilityService::logCS(int const partition)
        fhicl::ParameterSet MessageFacilityService::logCF(std::string const& filename, bool const append)
        fhicl::ParameterSet MessageFacilityService::logFS(std::string const& filename, bool const append, int const partition)
        fhicl::ParameterSet MessageFacilityService::logCFS(std::string const& filename, bool const append, int const partition)
        fhicl::ParameterSet MessageFacilityService::logArchive(std::string const& filename, bool const append)
      And:
        auto func(...)
          std::string const config("...");
          fhicl::ParameterSet result;
          fhicl::make_ParameterSet(config, result);
          ... intermediate_table tbl;
          ... parse_document(str, tbl);
          ... make_ParameterSet(tbl, ps);
          ... ... iterate over intermediate table
          ... ... use ParameterSet::put(key, value)
          return result;
        The following use a code sequence like above to create a table.
        auto default_destinations_config()
        auto default_statistics_config(fhicl::ParameterSet const& ordinaryDests)
        auto default_fwkJobReport_config()

-----

Callers of ParameterSetRegistry::put

./art/art/Framework/Services/System/TriggerNamesService_service.cc:36:  ParameterSetRegistry::put(trigger_pset_);
./art/art/Framework/Art/run_art.cc:134:    fhicl::ParameterSetRegistry::put(main_pset);
./art/art/Framework/Art/run_art.cc:179:    fhicl::ParameterSetRegistry::put(main_pset);
./art/art/Framework/EventProcessor/ServiceDirector.cc:22:    fhicl::ParameterSetRegistry::put(tmp);
./art/art/Framework/IO/Root/RootInputFile.cc:224:      fhicl::ParameterSetRegistry::put(pset);
./art/art/Framework/IO/Root/config_dumper.cc:192:    fhicl::ParameterSetRegistry::put(pset);
./fhiclcpp/fhiclcpp/DatabaseSupport.cc:56:  fhicl::ParameterSetRegistry::put(top);
./fhiclcpp/fhiclcpp/coding.cc:126:  return ParameterSetRegistry::put(value);
./fhiclcpp/fhiclcpp/detail/encode_extended_value.cc:54:    return ParameterSetRegistry::put(pset);

-----

This is the output of a fcl file parse, normally held as
a data member of an intermediate_table.  The structure
is recursive and may hold values, sequences, tables,
and tableids (@id::[0-9A-Fa-f]+)(hex representation of
a ParameterSetID).

enum value_tag UNKNOWN, NIL, BOOL, NUMBER, COMPLEX, STRING, SEQUENCE, TABLE, TABLEID

enum class Protection : unsigned char
  NONE,
  PROTECT_IGNORE,
  PROTECT_ERROR

+ to_string(Protection p) : string

class extended_value

  + atom_t : string
  + complex_t : pair<string, string>
  + sequence_t : vector<extended_value>
  + table_t : shims::map<string, extended_value>

  + in_prolog : bool
  + tag : value_tag
  + value : boost::any - THREADING - sequence_t, table_t usage
  + src_info : string // holds filename:linenum
  + protection : Protection

  + extended_value() : in_prolog(false) , tag(UNKNOWN) , value() , src_info() , protection(Protection::NONE) {}
  + extended_value(bool in_prolog, value_tag tag, boost::any value, Protection protection, string const& src = {}) : in_prolog(in_prolog) , tag(tag) , value(value) , src_info(src) , protection(protection) {}
  + extended_value(bool in_prolog, value_tag tag, boost::any value, string const& src = {}) : in_prolog(in_prolog) , tag(tag) , value(value) , src_info(src) , protection(Protection::NONE) {}

  + is_a(value_tag t) const : bool { return t == tag; }
  + to_string() const : string
  + set_prolog(bool new_prolog_state) : void
  + set_src_info(string const & src) : void { src_info = src; }
  + pretty_src_info() const : string
  + atom_t() const : atom_t { return boost::any_cast<atom_t>(value); }
  + complex_t() const : complex_t { return boost::any_cast<complex_t>(value); }
  + sequence_t() const : sequence_t { return boost::any_cast<sequence_t>(value); }
  + table_t() const : table_t { return boost::any_cast<table_t>(value); }

-----

Holder of an extended_value.  This is the result of parsing
a table in a fhicl file, and also the result of parsing an
entire fhicl file.

Note: This class is an analogue of ParameterSet, but does not
Note: have any relationship with ParameterSetRegistry like
Note: ParameterSet does.  This enforces the separation between
Note: fhiclcpp and art, but does force art to define a conversion
Note: from intermediate_table to ParameterSet.  Confusingly the
Note: worker functions that perform the conversion are here in
Note: fhicpp!!!
Note:
Note: The conversion works as follows:
Note:
Note: atom_t(string) --> boost::any(ps_atom_t(string))
Note: complex_t(pair<string, string>) --> boost::any('(' + pair.first + ',' pair.second + ')')
Note: sequence_t(vector<extended_value>) --> boost:any(ps_sequence_t(vector<boost::any>))
Note:   where the boost::any in the vector comes from encode(extended_value)
Note: TABLEID --> boost::any(ParameterSetID)
Note:   where the ParamsetSetID is constructed from the TABLEID string value
Note: table_t(shims::map<string, extended_value>) --> boost::any(ParameterSet)
Note:   where the ParameterSet is constructed by staring from a default-constructed
Note:   Parameter set and then calling ParameterSet::put(string, extended_value)
Note:   for every entry in the map where the extended_value was not in the prolog.
Note:   The resulting ParameterSet is put into the registry just before the conversion
Note:   finishes.
Note:

class intermediate_table

  + atom_t : extended_value::atom_t
  + complex_t : extended_value::complex_t
  + sequence_t : extended_value::sequence_t
  + table_t : extended_value::table_t
  + iterator : table_t::iterator
  + const_iterator : table_t::const_iterator

  - ex_val : extended_value - THREADING -  sequence_t, table_t usage of containers

  - pre_insert_(string const& name, extended_value const& value) : extended_value*
  - locate_(string const& name) : pair<extended_value*, bool>
  - split(string const& name) const : vector<string>

  + intermediate_table();

  + empty() const : bool
  + exists(string const& name) const : bool
  + erase(string const& name, bool in_prolog = false) : void
  + get(string const& name) : template<typename T> T 
  + put(string const& name, string const& value, bool in_prolog = false) : bool
  + put(string const& name, char const* value, bool in_prolog = false) : bool
  + put(string const& name, bool value, bool in_prolog = false) : bool
  + put(string const& name, complex<T> const& value, bool in_prolog = false) : template<typename T> bool
  + put(string const& name, vector<T> const& value, bool in_prolog = false) : template<typename T> bool
  + put( string const& name, T value, bool in_prolog = false) : template<typename T> typename enable_if<tt::is_numeric<T>::value, bool>::type
  + putEmptySequence(string const& name, bool in_prolog = false) : bool
  + putEmptyTable(string const& name, bool in_prolog = false) : bool
  + putNil(string const& name, bool in_prolog = false) : bool

  + begin() const : const_iterator
  + end() const : const_iterator

  + insert(string const& name, bool in_prolog, value_tag tag, boost::any const& value) : bool
  + insert(string const& name, extended_value const& value) : bool
  + insert(string const& name, extended_value&& value) : bool

  + find(string const& name) const : extended_value const&extended_value const&
  + locate(string const& name) : extended_value*
  + update(string const& name) : extended_value&

-----

Parameter Validation

-----

+ get_regex_replace_str(string const& istr) : string const { static regex const r("\\[|\\]"); auto ostr = regex_replace(istr, r, "\\$&"); return ostr; }

struct Name

  + value : string

  - index(size_t const i) static : string { return "[" + to_string(i) + "]"; }
  + sequence_element(size_t const i) static : Name { return Name{index(i)}; }
  + sequence_element(string const& key_stem, size_t const i) static : Name { return Name{key_stem + index(i)}; }
  + regex_safe(string const& key) static : string { return fhicl::get_regex_replace_str(key); }

  + Name(string const& name = "") explicit : value(name) {}

-----

class NameStackRegistry

  - names_ : vector<string>{} - THREADING

  + instance() static : NameStackRegistry& { static NameStackRegistry registry; return registry; }
  + end_of_ctor() static : void { instance().names_.pop_back(); }

  - NameStackRegistry() = default;
  + empty() const : bool { return names_.empty(); }
  + current() const : string { return names_.back(); }
  + clear() : void { names_.clear(); }
  + full_key(string const& name) : string
    {
      if (names_.empty() || regex_match(name, regex{R"(\[\d+\])"})) {
        names_.emplace_back(name);
      }
      else {
        names_.emplace_back("." + name);
      }
      return accumulate(names_.begin(), names_.end(), string{});
    }

-----

enum class par_type { ATOM, TABLE, SEQ_VECTOR, SEQ_ARRAY, TUPLE, DELEGATE, NTYPES }
enum class value_type { REQUIRED, REQUIRED_CONDITIONAL, DEFAULT, DEFAULT_CONDITIONAL, OPTIONAL, OPTIONAL_CONDITIONAL, NTYPES }

inline bool is_atom(par_type const pt) { return pt == par_type::ATOM; }
inline bool is_sequence(par_type const pt) { return pt == par_type::SEQ_VECTOR || pt == par_type::SEQ_ARRAY || pt == par_type::TUPLE; }
inline bool is_table(par_type const pt) { return pt == par_type::TABLE; }

-----

class ParameterMetadata

  - key_ : string {}
  - name_ : string {}
  - comment_ : string {}
  - valType_ : value_type {value_type::NTYPES}
  - parType_ : par_type {par_type::NTYPES}

  + ParameterMetadata() = default

  + ParameterMetadata(Name const& name = Name(),
                      Comment const& comment = Comment(""),
                      value_type const valType = value_type::NTYPES,
                      par_type const parType = par_type::NTYPES)
      : key_{NameStackRegistry::instance().full_key(name.value)}
      , name_{name.value}
      , comment_{comment.value}
      , valType_{valType}
      , parType_{parType}
    {
    }
  
  + key() const : string { return key_; }
  + name() const : string { return name_; }
  + comment() const : string { return comment_; }
  + has_default() const : bool { return valType_ == value_type::DEFAULT || valType_ == value_type::DEFAULT_CONDITIONAL; } 
  + is_optional() const : bool { return valType_ == value_type::OPTIONAL || valType_ == value_type::OPTIONAL_CONDITIONAL; }
  + is_conditional() const : bool { return valType_ == value_type::REQUIRED_CONDITIONAL || valType_ == value_type::OPTIONAL_CONDITIONAL || valType_ == value_type::DEFAULT_CONDITIONAL; }
  + type() const : par_type { return parType_; }
  + set_key(string const& key) : void { key_ = key; name_ = detail::strip_all_containing_names(key); }
  + set_value_type(value_type const vt) : void { valType_ = vt; }

-----

class ParameterBase

  - mdata_ : ParameterMetadata
  - maybeUse_ : function<bool()>

  - do_set_value(ParameterSet const&, bool trimParents) virtual = 0 : void

public:

  + ~ParameterBase() virtual = default

  + ParameterBase(Name const& name, Comment const& comment, value_type const vt, par_type const type, function<bool()> maybeUse = AlwaysUse())
      : mdata_{name, comment, vt, type}
      , maybeUse_{maybeUse}
    {
    }

  + key() const : string { return mdata_.key(); }
  + name() const : string { return mdata_.name(); }
  + comment() const : string { return mdata_.comment(); }
  + has_default() const : bool { return mdata_.has_default(); }
  + is_optional() const : bool { return mdata_.is_optional(); }
  + is_conditional() const : bool { return mdata_.is_conditional(); }
  + parameter_type() const : par_type { return mdata_.type(); }
  + should_use() const : bool { return maybeUse_(); }
  + set_value(ParameterSet const& ps, bool trimParents) : void { do_set_value(ps, trimParents); }
  + set_value_type(value_type const vt) : void { mdata_.set_value_type(vt); }
  + set_key(string const& key) : void { mdata_.set_key(key); }

-----

class AtomBase : public ParameterBase

  + AtomBase(Name const& name, Comment const& comment, value_type const vt, function<bool()> maybeUse)
      : ParameterBase{name, comment, vt, par_type::ATOM, maybeUse}
    {
    }

  + stringified_value() const : string { return get_stringified_value(); }
  - get_stringified_value() const virtual = 0 : string

-----

class TableMemberRegistry

  friend class RegisterIfTableMember

  template<typename T, typename KeysToIgnore>
  friend class fhicl::Table

  template<typename T>
  friend class fhicl::OptionalTable

  - using base_ptr : cet::exempt_ptr<ParameterBase>;
  - using table_members_t : vector<base_ptr>;

  - tables_ : stack<table_members_t> - THREADING

  - instance() static : TableMemberRegistry& { static TableMemberRegistry registry; return registry; }

  - TableMemberRegistry() = default
  + TableMemberRegistry(TableMemberRegistry const&) = delete
  + TableMemberRegistry(TableMemberRegistry&&) = delete
  + TableMemberRegistry& operator=(TableMemberRegistry const&) = delete
  + TableMemberRegistry& operator=(TableMemberRegistry&&) = delete
  - release_members() : vector<base_ptr> { vector<base_ptr> result; swap(tables_.top(), result); tables_.pop(); return result; }
  - emplace_table_member(ParameterBase* pb) : void { tables_.top().emplace_back(pb); }
  - new_table() : void { tables_.emplace(); }

-----

class RegisterIfTableMember

  + RegisterIfTableMember(ParameterBase* pb)
    {
      if (is_table_member(pb->key())) {
        TableMemberRegistry::instance().emplace_table_member(pb);
      }
      if (is_table(pb->parameter_type())) {
        TableMemberRegistry::instance().new_table();
      }
    }

-----

template<typename T>
class Atom final : public  detail::AtomBase, private detail::RegisterIfTableMember

public:

  + using dtype : T;
  + using rtype : T;

  - value_ : shared_ptr<T> - THREADING -

  + Atom(Name&& name) explicit
      : Atom{move(name)
      , Comment("")}
    {}

  + Atom(Name&& name, Comment&& comment) explicit
      : AtomBase{move(name), move(comment), value_type::REQUIRED, detail::AlwaysUse()}
      , RegisterIfTableMember{this}
      , value_{make_shared<T>()}
    { 
      NameStackRegistry::end_of_ctor();
    }

  + Atom(Name&& name, Comment&& comment, function<bool()> maybeUse) explicit
      : AtomBase{move(name), move(comment), value_type::REQUIRED_CONDITIONAL, maybeUse}
      , RegisterIfTableMember{this}
      , value_{make_shared<T>()}
    {
      NameStackRegistry::end_of_ctor();
    }

  + Atom(Name&& name, T const& dflt_value) explicit
      : Atom{move(name)
      , Comment("")
      , dflt_value}
    {}

  + Atom(Name&& name, Comment&& comment, T const& dflt_value) explicit
      : AtomBase{move(name), move(comment), value_type::DEFAULT, detail::AlwaysUse()}
      , RegisterIfTableMember{this}
      , value_{make_shared<T>(dflt_value)}
    {
      NameStackRegistry::end_of_ctor();
    }

  + Atom(Name&& name, Comment&& comment, function<bool()> maybeUse, T const& dflt_value) explicit
      : AtomBase{move(name), move(comment), value_type::DEFAULT_CONDITIONAL, maybeUse}
      , RegisterIfTableMember{this}
      , value_{make_shared<T>(dflt_value)}
    {
      NameStackRegistry::end_of_ctor();
    }

  + operator()() const : auto const& { return *value_; }

  - get_stringified_value() const override : string
    {
      stringstream oss;
      if (has_default()) {
        using namespace detail::yes_defaults;
        oss << maybe_quotes<T>(*value_);
      }
      else {
        using namespace detail::no_defaults;
        oss << expected_types<T>();
      }
      return oss.str();
    }

  - do_set_value(ParameterSet const&, bool const trimParent) override : void
    {
      string const& rkey = key();
      string const& key = trimParent ? detail::strip_first_containing_name(rkey) : rkey;
      if (has_default()) {
        pset.get_if_present<T>(key, *value_);
      }
      else {
        value_ = make_shared<T>(pset.get<T>(key));
      }
    }

-----

